//go:build windows

package device

import (
	"fmt"
	"io"
	"strings"
	"sync"

	"github.com/allanpk716/record_center/internal/logger"
)

// OLEWPDAccessor OLE WPD设备访问器
type OLEWPDAccessor struct {
	log       *logger.Logger
	ole       *OLEShellAccessor
	connected bool
	device    *DeviceInfo
	mutex     sync.RWMutex
}

// NewOLEWPDAccessor 创建新的OLE WPD访问器
func NewOLEWPDAccessor(log *logger.Logger) *OLEWPDAccessor {
	return &OLEWPDAccessor{
		log: log,
	}
}

// ConnectToDevice 连接到设备
func (o *OLEWPDAccessor) ConnectToDevice(deviceName, vid, pid string) error {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	o.log.Debug("OLE WPD连接设备: %s (VID:%s, PID:%s)", deviceName, vid, pid)

	// 初始化OLE Shell
	oleShell := NewOLEShellAccessor(o.log)
	if err := oleShell.Initialize(); err != nil {
		return fmt.Errorf("初始化OLE Shell失败: %w", err)
	}

	// 查找便携式设备
	devices, err := oleShell.FindPortableDevices()
	if err != nil {
		oleShell.Close()
		return fmt.Errorf("查找便携式设备失败: %w", err)
	}

	// 查找目标设备
	var targetDevice *DeviceInfo
	for _, device := range devices {
		if strings.Contains(strings.ToLower(device.Name), strings.ToLower(deviceName)) ||
			strings.Contains(strings.ToLower(device.DeviceID), strings.ToLower(vid)) ||
			strings.Contains(strings.ToLower(device.DeviceID), strings.ToLower(pid)) {
			targetDevice = device
			break
		}
	}

	if targetDevice == nil {
		// 如果精确匹配失败，尝试模糊匹配
		for _, device := range devices {
			if o.isTargetDevice(device, deviceName, vid, pid) {
				targetDevice = device
				break
			}
		}
	}

	if targetDevice == nil {
		oleShell.Close()
		return fmt.Errorf("未找到目标设备: %s", deviceName)
	}

	o.ole = oleShell
	o.device = targetDevice
	o.connected = true

	o.log.Info("OLE WPD成功连接到设备: %s", targetDevice.Name)
	return nil
}

// isTargetDevice 检查是否为目标设备（更宽松的匹配）
func (o *OLEWPDAccessor) isTargetDevice(device *DeviceInfo, deviceName, vid, pid string) bool {
	deviceLower := strings.ToLower(device.Name)
	targetLower := strings.ToLower(deviceName)

	// 检查设备名称
	if strings.Contains(deviceLower, targetLower) {
		return true
	}

	// 检查VID/PID
	deviceIDLower := strings.ToLower(device.DeviceID)
	if strings.Contains(deviceIDLower, strings.ToLower(vid)) {
		return true
	}

	// 检查是否为录音相关设备
	if strings.Contains(deviceLower, "录音") ||
	   strings.Contains(deviceLower, "record") ||
	   strings.Contains(deviceLower, "voice") ||
	   strings.Contains(deviceLower, "audio") {
		return true
	}

	return false
}

// ListFiles 列出设备文件
func (o *OLEWPDAccessor) ListFiles(basePath string) ([]*FileInfo, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return nil, fmt.Errorf("设备未连接")
	}

	o.log.Debug("OLE WPD列出文件: %s", basePath)

	// 使用设备路径搜索
	devicePath := o.device.DeviceID
	if devicePath == "" {
		devicePath = o.device.Name
	}

	// 搜索.opus文件
	files, err := o.ole.ListDeviceFiles(devicePath, ".opus")
	if err != nil {
		o.log.Debug("OLE WPD列出文件失败: %v", err)
		return nil, fmt.Errorf("列出设备文件失败: %w", err)
	}

	o.log.Info("OLE WPD找到 %d 个文件", len(files))
	return files, nil
}

// GetFileStream 获取文件流
func (o *OLEWPDAccessor) GetFileStream(filePath string) (io.ReadCloser, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return nil, fmt.Errorf("设备未连接")
	}

	o.log.Debug("OLE WPD获取文件流: %s", filePath)

	// 由于OLE COM文件流访问复杂，暂时返回错误
	// 可以后续实现通过CopyHere方法复制文件到临时目录
	return nil, fmt.Errorf("文件流访问尚未实现，建议使用文件复制方法")
}

// CopyFileToTemp 复制文件到临时目录
func (o *OLEWPDAccessor) CopyFileToTemp(devicePath, fileName, tempDir string) (string, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return "", fmt.Errorf("设备未连接")
	}

	o.log.Debug("复制文件到临时目录: %s -> %s", fileName, tempDir)

	// 这里可以实现OLE COM的文件复制功能
	// 暂时返回错误提示
	return "", fmt.Errorf("文件复制功能尚未实现")
}

// Close 关闭连接
func (o *OLEWPDAccessor) Close() error {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	if o.ole != nil {
		o.ole.Close()
		o.ole = nil
	}

	o.connected = false
	o.device = nil

	o.log.Debug("OLE WPD连接已关闭")
	return nil
}

// IsConnected 检查连接状态
func (o *OLEWPDAccessor) IsConnected() bool {
	o.mutex.RLock()
	defer o.mutex.RUnlock()
	return o.connected
}

// GetDeviceInfo 获取设备信息
func (o *OLEWPDAccessor) GetDeviceInfo() *DeviceInfo {
	o.mutex.RLock()
	defer o.mutex.RUnlock()
	return o.device
}

// GetLastError 获取最后的错误
func (o *OLEWPDAccessor) GetLastError() error {
	// 实现错误记录
	return nil
}

// 实现MTPInterface接口的其他方法

// GetFilesByPattern 按模式获取文件
func (o *OLEWPDAccessor) GetFilesByPattern(pattern string) ([]*FileInfo, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return nil, fmt.Errorf("设备未连接")
	}

	devicePath := o.device.DeviceID
	if devicePath == "" {
		devicePath = o.device.Name
	}

	return o.ole.ListDeviceFiles(devicePath, pattern)
}

// GetFileContent 获取文件内容（字节）
func (o *OLEWPDAccessor) GetFileContent(filePath string) ([]byte, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return nil, fmt.Errorf("设备未连接")
	}

	// 暂时返回空内容
	return []byte{}, fmt.Errorf("文件内容获取尚未实现")
}

// CopyFileToPath 复制文件到指定路径
func (o *OLEWPDAccessor) CopyFileToPath(sourcePath, destPath string) error {
	// 暂时简化实现
	o.log.Debug("复制文件: %s -> %s", sourcePath, destPath)
	return fmt.Errorf("文件复制功能尚未实现")
}

// GetDeviceProperties 获取设备属性
func (o *OLEWPDAccessor) GetDeviceProperties() (map[string]interface{}, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.connected {
		return nil, fmt.Errorf("设备未连接")
	}

	properties := make(map[string]interface{})
	properties["Name"] = o.device.Name
	properties["DeviceID"] = o.device.DeviceID
	properties["VID"] = o.device.VID
	properties["PID"] = o.device.PID
	properties["Connected"] = o.connected

	return properties, nil
}