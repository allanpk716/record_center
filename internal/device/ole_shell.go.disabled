//go:build windows

package device

import (
	"fmt"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/allanpk716/record_center/internal/logger"
	"github.com/go-ole/go-ole"
	"github.com/go-ole/go-ole/oleutil"
)

// OLEShellAccessor go-ole Shell访问器
type OLEShellAccessor struct {
	log           *logger.Logger
	initialized   bool
	shell         *ole.IDispatch
	mutex         sync.RWMutex
}

// NewOLEShellAccessor 创建新的OLE Shell访问器
func NewOLEShellAccessor(log *logger.Logger) *OLEShellAccessor {
	return &OLEShellAccessor{
		log: log,
	}
}

// Initialize 初始化OLE Shell访问器
func (o *OLEShellAccessor) Initialize() error {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	if o.initialized {
		return nil
	}

	// 初始化OLE
	if err := ole.CoInitialize(0); err != nil {
		return fmt.Errorf("OLE初始化失败: %v", err)
	}

	// 创建Shell.Application对象
	unknown, err := ole.CreateObject("Shell.Application")
	if err != nil {
		ole.CoUninitialize()
		return fmt.Errorf("创建Shell.Application失败: %v", err)
	}

	// 转换为IDispatch
	shell, err := unknown.QueryInterface(ole.IID_IDispatch)
	if err != nil {
		unknown.Release()
		ole.CoUninitialize()
		return fmt.Errorf("查询IDispatch接口失败: %v", err)
	}

	o.shell = shell
	o.initialized = true

	o.log.Debug("OLE Shell访问器初始化成功")
	return nil
}

// FindPortableDevices 查找便携式设备
func (o *OLEShellAccessor) FindPortableDevices() ([]*DeviceInfo, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.initialized {
		return nil, fmt.Errorf("OLE访问器未初始化")
	}

	o.log.Debug("开始查找便携式设备")

	// 获取便携式设备命名空间 (17)
	result, err := oleutil.CallMethod(o.shell, "Namespace", 17)
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备命名空间失败: %v", err)
	}

	portable, ok := result.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备命名空间不是IDispatch对象")
	}
	defer portable.Release()

	// 获取所有项目
	itemsResult, err := oleutil.GetProperty(portable, "Items")
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备项目失败: %v", err)
	}

	items, ok := itemsResult.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备项目不是IDispatch对象")
	}
	defer items.Release()

	// 获取项目数量
	countResult, err := oleutil.GetProperty(items, "Count")
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备数量失败: %v", err)
	}

	count, ok := countResult.Val.(int32)
	if !ok {
		return nil, fmt.Errorf("便携式设备数量格式错误")
	}

	o.log.Debug("便携式设备命名空间包含 %d 个项目", count)

	var devices []*DeviceInfo
	for i := int32(0); i < count; i++ {
		// 获取单个项目
		itemResult, err := oleutil.CallMethod(items, "Item", i)
		if err != nil {
			o.log.Debug("获取项目 %d 失败: %v", i, err)
			continue
		}

		item, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 获取项目名称
		nameResult, err := oleutil.GetProperty(item, "Name")
		if err != nil {
			item.Release()
			continue
		}

		name, ok := nameResult.Val.(string)
		if !ok {
			item.Release()
			continue
		}

		// 检查是否为录音设备
		if o.isRecordingDevice(name) {
			device := &DeviceInfo{
				Name:     name,
				DeviceID: name, // 临时使用名称
			}

			// 尝试获取路径
			if pathResult, err := oleutil.GetProperty(item, "Path"); err == nil {
				if path, ok := pathResult.Val.(string); ok {
					device.DeviceID = path
				}
			}

			devices = append(devices, device)
			o.log.Debug("找到录音设备: %s", name)
		}

		item.Release()

		// 限制搜索数量
		if len(devices) >= 10 {
			break
		}
	}

	return devices, nil
}

// ListDeviceFiles 列出设备文件
func (o *OLEShellAccessor) ListDeviceFiles(devicePath string, searchPattern string) ([]*FileInfo, error) {
	o.mutex.RLock()
	defer o.mutex.RUnlock()

	if !o.initialized {
		return nil, fmt.Errorf("OLE访问器未初始化")
	}

	o.log.Debug("开始列出设备文件: %s", devicePath)

	var files []*FileInfo
	err := o.enumerateFiles(devicePath, "", searchPattern, 4, &files)
	if err != nil {
		return nil, fmt.Errorf("枚举文件失败: %v", err)
	}

	o.log.Debug("找到 %d 个文件", len(files))
	return files, nil
}

// enumerateFiles 递归枚举文件
func (o *OLEShellAccessor) enumerateFiles(devicePath, currentPath, searchPattern string, maxDepth int, files *[]*FileInfo) error {
	if maxDepth <= 0 {
		return nil
	}

	// 获取文件夹对象
	var folder *ole.IDispatch
	var err error

	if currentPath == "" {
		// 根路径，尝试直接获取设备
		folder, err = o.getDeviceFolder(devicePath)
	} else {
		// 子路径
		folder, err = o.getSubFolder(devicePath, currentPath)
	}

	if err != nil {
		return fmt.Errorf("获取文件夹失败: %v", err)
	}
	if folder == nil {
		return nil
	}
	defer folder.Release()

	// 获取文件夹项目
	itemsResult, err := oleutil.GetProperty(folder, "Items")
	if err != nil {
		return fmt.Errorf("获取文件夹项目失败: %v", err)
	}

	items, ok := itemsResult.ToIDispatch()
	if !ok {
		return fmt.Errorf("文件夹项目不是IDispatch对象")
	}
	defer items.Release()

	// 获取项目数量
	countResult, err := oleutil.GetProperty(items, "Count")
	if err != nil {
		return fmt.Errorf("获取项目数量失败: %v", err)
	}

	count, ok := countResult.Val.(int32)
	if !ok {
		return fmt.Errorf("项目数量格式错误")
	}

	for i := int32(0); i < count; i++ {
		// 获取单个项目
		itemResult, err := oleutil.CallMethod(items, "Item", i)
		if err != nil {
			continue
		}

		item, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 获取项目信息
		nameResult, err := oleutil.GetProperty(item, "Name")
		if err != nil {
			item.Release()
			continue
		}

		name, ok := nameResult.Val.(string)
		if !ok {
			item.Release()
			continue
		}

		// 检查是否为文件夹
		isFolderResult, err := oleutil.GetProperty(item, "IsFolder")
		if err != nil {
			item.Release()
			continue
		}

		isFolder, ok := isFolderResult.Val.(bool)
		if !ok {
			isFolder = false
		}

		// 构建完整路径
		fullPath := filepath.Join(currentPath, name)

		if !isFolder {
			// 检查文件扩展名
			if searchPattern == "" || strings.Contains(strings.ToLower(name), searchPattern) {
				// 获取文件大小
				var size int64 = 0
				if sizeResult, err := oleutil.GetProperty(item, "Size"); err == nil {
					if s, ok := sizeResult.Val.(int64); ok {
						size = s
					}
				}

				// 获取修改时间
				var modTime time.Time = time.Now()
				if modResult, err := oleutil.GetProperty(item, "ModifyDate"); err == nil {
					if t, ok := modResult.Val.(time.Time); ok {
						modTime = t
					}
				}

				file := &FileInfo{
					Name:         name,
					Path:         fullPath,
					RelativePath: name,
					Size:         size,
					IsOpus:       strings.ToLower(filepath.Ext(name)) == ".opus",
					ModTime:      modTime,
				}
				*files = append(*files, file)
			}
		} else {
			// 递归搜索子文件夹
			if err := o.enumerateFiles(devicePath, fullPath, searchPattern, maxDepth-1, files); err != nil {
				o.log.Debug("枚举子文件夹失败: %s - %v", name, err)
			}
		}

		item.Release()

		// 限制文件数量
		if len(*files) >= 1000 {
			break
		}
	}

	return nil
}

// getDeviceFolder 获取设备文件夹
func (o *OLEShellAccessor) getDeviceFolder(devicePath string) (*ole.IDispatch, error) {
	// 尝试直接通过Namespace获取设备
	result, err := oleutil.CallMethod(o.shell, "Namespace", devicePath)
	if err == nil {
		if folder, ok := result.ToIDispatch(); ok {
			return folder, nil
		}
	}

	// 如果失败，尝试从便携式设备中查找
	return o.findDeviceInPortableDevices(devicePath)
}

// findDeviceInPortableDevices 在便携式设备中查找设备
func (o *OLEShellAccessor) findDeviceInPortableDevices(devicePath string) (*ole.IDispatch, error) {
	// 获取便携式设备
	result, err := oleutil.CallMethod(o.shell, "Namespace", 17)
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备失败: %v", err)
	}

	portable, ok := result.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备不是IDispatch对象")
	}
	defer portable.Release()

	// 获取所有设备
	itemsResult, err := oleutil.GetProperty(portable, "Items")
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备项目失败: %v", err)
	}

	items, ok := itemsResult.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备项目不是IDispatch对象")
	}
	defer items.Release()

	// 获取项目数量
	countResult, err := oleutil.GetProperty(items, "Count")
	if err != nil {
		return nil, fmt.Errorf("获取设备数量失败: %v", err)
	}

	count, ok := countResult.Val.(int32)
	if !ok {
		return nil, fmt.Errorf("设备数量格式错误")
	}

	for i := int32(0); i < count; i++ {
		itemResult, err := oleutil.CallMethod(items, "Item", i)
		if err != nil {
			continue
		}

		item, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 检查名称是否匹配
		nameResult, err := oleutil.GetProperty(item, "Name")
		if err != nil {
			item.Release()
			continue
		}

		name, ok := nameResult.Val.(string)
		if !ok {
			item.Release()
			continue
		}

		if o.isRecordingDevice(name) {
			return item, nil // 返回找到的设备，不释放
		}

		item.Release()
	}

	return nil, fmt.Errorf("未找到设备: %s", devicePath)
}

// getSubFolder 获取子文件夹
func (o *OLEShellAccessor) getSubFolder(devicePath, subPath string) (*ole.IDispatch, error) {
	folder, err := o.getDeviceFolder(devicePath)
	if err != nil {
		return nil, err
	}
	defer folder.Release()

	// 解析子路径
	parts := strings.Split(subPath, string(filepath.Separator))
	current := folder

	for _, part := range parts {
		if part == "" {
			continue
		}

		// 获取子文件夹
		subResult, err := oleutil.CallMethod(current, "ParseName", part)
		if err != nil {
			return nil, fmt.Errorf("解析子路径失败: %v", err)
		}

		sub, ok := subResult.ToIDispatch()
		if !ok {
			return nil, fmt.Errorf("子文件夹不是IDispatch对象")
		}

		current.Release()
		current = sub
	}

	return current, nil
}

// isRecordingDevice 检查是否为录音设备
func (o *OLEShellAccessor) isRecordingDevice(name string) bool {
	name = strings.ToLower(name)
	return strings.Contains(name, "sr302") ||
		strings.Contains(name, "录音") ||
		strings.Contains(name, "record") ||
		strings.Contains(name, "voice") ||
		strings.Contains(name, "audio")
}

// Close 关闭OLE Shell访问器
func (o *OLEShellAccessor) Close() error {
	o.mutex.Lock()
	defer o.mutex.Unlock()

	if o.shell != nil {
		o.shell.Release()
		o.shell = nil
	}

	if o.initialized {
		ole.CoUninitialize()
		o.initialized = false
	}

	o.log.Debug("OLE Shell访问器已关闭")
	return nil
}

// IsConnected 检查连接状态
func (o *OLEShellAccessor) IsConnected() bool {
	o.mutex.RLock()
	defer o.mutex.RUnlock()
	return o.initialized
}