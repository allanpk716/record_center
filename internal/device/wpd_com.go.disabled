//go:build windows

package device

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
	"unsafe"

	"github.com/allanpk716/record_center/internal/logger"
	"github.com/go-ole/go-ole"
)

var (
	oleInitialized bool
	oleMutex       sync.Mutex
)

// COMInterface go-ole COM接口封装
type COMInterface struct {
	log            *logger.Logger
	shell          *ole.IUnknown
	shellDispatch  *ole.IDispatch
	initialized    bool
}

// NewCOMInterface 创建新的COM接口
func NewCOMInterface(log *logger.Logger) (*COMInterface, error) {
	oleMutex.Lock()
	defer oleMutex.Unlock()

	// 初始化OLE库（如果还没有初始化）
	if !oleInitialized {
		if err := ole.CoInitializeEx(0, ole.COINIT_APARTMENTTHREADED); err != nil {
			return nil, fmt.Errorf("OLE初始化失败: %v", err)
		}
		oleInitialized = true
	}

	com := &COMInterface{
		log: log,
	}

	return com, nil
}

// Initialize 初始化COM接口
func (c *COMInterface) Initialize() error {
	// 创建Shell Application对象
	classID, err := ole.CLASSIDFromString("{13709620-C279-11CE-A49E-444553540000}") // Shell.Application
	if err != nil {
		return fmt.Errorf("获取Shell.Application CLSID失败: %v", err)
	}

	unknown, err := ole.CreateInstance(classID, nil, ole.CLSCTX_LOCAL_SERVER)
	if err != nil {
		return fmt.Errorf("创建Shell.Application实例失败: %v", err)
	}

	// 查询IDispatch接口
	dispatch, err := unknown.QueryInterface(ole.IID_IDispatch)
	if err != nil {
		unknown.Release()
		return fmt.Errorf("查询IDispatch接口失败: %v", err)
	}

	c.shell = unknown
	c.shellDispatch = dispatch
	c.initialized = true

	c.log.Debug("COM接口初始化成功")
	return nil
}

// FindPortableDevices 查找便携式设备
func (c *COMInterface) FindPortableDevices() ([]*DeviceInfo, error) {
	if !c.initialized {
		return nil, fmt.Errorf("COM接口未初始化")
	}

	// 获取便携式设备命名空间 (17)
	result, err := c.callShellMethod("Namespace", int32(17))
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备命名空间失败: %v", err)
	}

	portableFolder, ok := result.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备命名空间不是IDispatch对象")
	}
	defer portableFolder.Release()

	// 获取项目集合
	itemsResult, err := c.callMethod(portableFolder, "Items")
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备项目失败: %v", err)
	}

	itemsVariant, ok := itemsResult.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备项目不是IDispatch对象")
	}
	defer itemsVariant.Release()

	// 获取项目数量
	countResult, err := c.callMethod(itemsVariant, "Count")
	if err != nil {
		return nil, fmt.Errorf("获取便携式设备数量失败: %v", err)
	}

	count, ok := countResult.Value().(int32)
	if !ok {
		return nil, fmt.Errorf("便携式设备数量格式错误")
	}

	var devices []*DeviceInfo
	for i := int32(0); i < count; i++ {
		// 获取单个项目
		itemResult, err := c.callMethod(itemsVariant, "Item", i)
		if err != nil {
			c.log.Debug("获取项目 %d 失败: %v", i, err)
			continue
		}

		itemVariant, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 获取项目名称
		nameResult, err := c.callMethod(itemVariant, "Name")
		if err != nil {
			itemVariant.Release()
			continue
		}

		name, ok := nameResult.Value().(string)
		if !ok {
			itemVariant.Release()
			continue
		}

		// 检查是否为录音笔设备
		if c.isRecordingDevice(name) {
			device := &DeviceInfo{
				Name:     name,
				DeviceID: name, // 临时使用名称作为ID
			}

			// 尝试获取更多信息
			if pathResult, err := c.callMethod(itemVariant, "Path"); err == nil {
				if path, ok := pathResult.Value().(string); ok {
					device.DeviceID = path
				}
			}

			devices = append(devices, device)
			c.log.Debug("找到录音设备: %s", name)
		}

		itemVariant.Release()

		// 限制搜索数量
		if len(devices) >= 10 {
			break
		}
	}

	return devices, nil
}

// ListDeviceFiles 列出设备文件
func (c *COMInterface) ListDeviceFiles(devicePath string, searchPattern string) ([]*FileInfo, error) {
	if !c.initialized {
		return nil, fmt.Errorf("COM接口未初始化")
	}

	c.log.Debug("开始列出设备文件: %s", devicePath)

	// 获取设备文件夹
	deviceFolder, err := c.getDeviceFolder(devicePath)
	if err != nil {
		return nil, fmt.Errorf("获取设备文件夹失败: %v", err)
	}
	defer deviceFolder.Release()

	var files []*FileInfo
	err = c.enumerateFolder(deviceFolder, "", searchPattern, 4, &files)
	if err != nil {
		return nil, fmt.Errorf("枚举文件失败: %v", err)
	}

	c.log.Debug("找到 %d 个文件", len(files))
	return files, nil
}

// GetFileContent 获取文件内容
func (c *COMInterface) GetFileContent(filePath string) ([]byte, error) {
	if !c.initialized {
		return nil, fmt.Errorf("COM接口未初始化")
	}

	// 这里实现文件内容读取
	// 由于COM文件流访问比较复杂，暂时返回错误
	return nil, fmt.Errorf("文件流访问尚未实现")
}

// Close 关闭COM接口
func (c *COMInterface) Close() error {
	if c.shellDispatch != nil {
		c.shellDispatch.Release()
		c.shellDispatch = nil
	}

	if c.shell != nil {
		c.shell.Release()
		c.shell = nil
	}

	c.initialized = false
	c.log.Debug("COM接口已关闭")
	return nil
}

// 内部辅助方法

// isRecordingDevice 检查是否为录音设备
func (c *COMInterface) isRecordingDevice(name string) bool {
	name = strings.ToLower(name)
	return strings.Contains(name, "sr302") ||
		strings.Contains(name, "录音") ||
		strings.Contains(name, "record") ||
		strings.Contains(name, "voice") ||
		strings.Contains(name, "audio")
}

// callShellMethod 调用Shell方法
func (c *COMInterface) callShellMethod(method string, args ...interface{}) (*ole.VARIANT, error) {
	return c.callMethod(c.shellDispatch, method, args...)
}

// callMethod 调用COM方法
func (c *COMInterface) callMethod(disp *ole.IDispatch, method string, args ...interface{}) (*ole.VARIANT, error) {
	// 获取方法ID
	methodID, err := disp.GetIDsOfNames([]string{method})
	if err != nil {
		return nil, fmt.Errorf("获取方法ID失败: %v", err)
	}

	// 准备参数
	dispparams := ole.DISPPARAMS{}
	var argsVariant []ole.VARIANT

	// 反转参数顺序（COM约定）
	for i := len(args) - 1; i >= 0; i-- {
		var variant ole.VARIANT
		err := ole.VariantInit(&variant)
		if err != nil {
			return nil, fmt.Errorf("初始化参数失败: %v", err)
		}

		switch v := args[i].(type) {
		case int32:
			variant.VT = ole.VT_I4
			variant.Val = int64(v)
		case string:
			variant.VT = ole.VT_BSTR
			variant.Val = int64(uintptr(unsafe.Pointer(ole.SysAllocString(ole.Bstr(v)))))
		default:
			return nil, fmt.Errorf("不支持的参数类型: %T", v)
		}

		argsVariant = append(argsVariant, variant)
	}

	dispparams.Args = argsVariant
	dispparams.cArgs = uint32(len(argsVariant))

	// 调用方法
	var result ole.VARIANT
	err = ole.VariantInit(&result)
	if err != nil {
		return nil, fmt.Errorf("初始化结果失败: %v", err)
	}

	err = disp.Invoke(methodID[0], ole.IID_NULL, 0, ole.DISPATCH_METHOD, dispparams, &result, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("调用方法失败: %v", err)
	}

	// 清理参数
	for _, variant := range argsVariant {
		if variant.VT == ole.VT_BSTR {
			ole.SysFreeString(ole.Bstr(uintptr(variant.Val)))
		}
	}

	return &result, nil
}

// getDeviceFolder 获取设备文件夹
func (c *COMInterface) getDeviceFolder(devicePath string) (*ole.IDispatch, error) {
	// 尝试通过Shell.Namespace获取
	result, err := c.callShellMethod("Namespace", devicePath)
	if err != nil {
		// 如果失败，尝试从便携式设备中查找
		return c.findDeviceInPortableDevices(devicePath)
	}

	folder, ok := result.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("设备文件夹不是IDispatch对象")
	}

	return folder, nil
}

// findDeviceInPortableDevices 在便携式设备中查找设备
func (c *COMInterface) findDeviceInPortableDevices(devicePath string) (*ole.IDispatch, error) {
	// 获取便携式设备
	result, err := c.callShellMethod("Namespace", int32(17))
	if err != nil {
		return nil, err
	}

	portableFolder, ok := result.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备不是IDispatch对象")
	}
	defer portableFolder.Release()

	// 获取所有设备
	itemsResult, err := c.callMethod(portableFolder, "Items")
	if err != nil {
		return nil, err
	}

	items, ok := itemsResult.ToIDispatch()
	if !ok {
		return nil, fmt.Errorf("便携式设备项目不是IDispatch对象")
	}
	defer items.Release()

	// 遍历查找目标设备
	countResult, err := c.callMethod(items, "Count")
	if err != nil {
		return nil, err
	}

	count, ok := countResult.Value().(int32)
	if !ok {
		return nil, fmt.Errorf("设备数量格式错误")
	}

	for i := int32(0); i < count; i++ {
		itemResult, err := c.callMethod(items, "Item", i)
		if err != nil {
			continue
		}

		item, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 检查名称是否匹配
		nameResult, err := c.callMethod(item, "Name")
		if err != nil {
			item.Release()
			continue
		}

		name, ok := nameResult.Value().(string)
		if !ok {
			item.Release()
			continue
		}

		if c.isRecordingDevice(name) {
			return item, nil // 返回找到的设备，不释放
		}

		item.Release()
	}

	return nil, fmt.Errorf("未找到设备: %s", devicePath)
}

// enumerateFolder 枚举文件夹内容
func (c *COMInterface) enumerateFolder(folder *ole.IDispatch, basePath, searchPattern string, maxDepth int, files *[]*FileInfo) error {
	if maxDepth <= 0 {
		return nil
	}

	// 获取文件夹项目
	itemsResult, err := c.callMethod(folder, "Items")
	if err != nil {
		return fmt.Errorf("获取文件夹项目失败: %v", err)
	}

	items, ok := itemsResult.ToIDispatch()
	if !ok {
		return fmt.Errorf("文件夹项目不是IDispatch对象")
	}
	defer items.Release()

	// 获取项目数量
	countResult, err := c.callMethod(items, "Count")
	if err != nil {
		return fmt.Errorf("获取项目数量失败: %v", err)
	}

	count, ok := countResult.Value().(int32)
	if !ok {
		return fmt.Errorf("项目数量格式错误")
	}

	for i := int32(0); i < count; i++ {
		itemResult, err := c.callMethod(items, "Item", i)
		if err != nil {
			continue
		}

		item, ok := itemResult.ToIDispatch()
		if !ok {
			continue
		}

		// 获取项目信息
		nameResult, err := c.callMethod(item, "Name")
		if err != nil {
			item.Release()
			continue
		}

		name, ok := nameResult.Value().(string)
		if !ok {
			item.Release()
			continue
		}

		// 检查是否为文件夹
		isFolderResult, err := c.callMethod(item, "IsFolder")
		if err != nil {
			item.Release()
			continue
		}

		isFolder, ok := isFolderResult.Value().(bool)
		if !ok {
			isFolder = false
		}

		// 构建完整路径
		fullPath := filepath.Join(basePath, name)

		if !isFolder {
			// 检查文件扩展名
			if searchPattern == "" || strings.Contains(strings.ToLower(name), searchPattern) {
				// 获取文件大小
				var size int64 = 0
				if sizeResult, err := c.callMethod(item, "Size"); err == nil {
					if s, ok := sizeResult.Value().(int64); ok {
						size = s
					}
				}

				// 获取修改时间
				var modTime time.Time = time.Now()
				if modResult, err := c.callMethod(item, "ModifyDate"); err == nil {
					if t, ok := modResult.Value().(time.Time); ok {
						modTime = t
					}
				}

				file := &FileInfo{
					Name:         name,
					Path:         fullPath,
					RelativePath: name,
					Size:         size,
					IsOpus:       strings.ToLower(filepath.Ext(name)) == ".opus",
					ModTime:      modTime,
				}
				*files = append(*files, file)
			}
		} else {
			// 递归搜索子文件夹
			if err := c.enumerateFolder(item, fullPath, searchPattern, maxDepth-1, files); err != nil {
				c.log.Debug("枚举子文件夹失败: %s - %v", name, err)
			}
		}

		item.Release()

		// 限制文件数量
		if len(*files) >= 1000 {
			break
		}
	}

	return nil
}

// CleanupOle 清理OLE库（程序退出时调用）
func CleanupOle() {
	oleMutex.Lock()
	defer oleMutex.Unlock()

	if oleInitialized {
		ole.CoUninitialize()
		oleInitialized = false
	}
}