//go:build windows

package device

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/allanpk716/record_center/internal/logger"
)

// WindowsShellCOM Windows Shell COM访问实现
type WindowsShellCOM struct {
	log     *logger.Logger
	// bridge  *CGOBridge  // 暂时禁用CGO
	config  *ConnectionConfig
	device  *DeviceInfo
	connected bool
}

// NewWindowsShellCOM 创建新的Windows Shell COM访问器
func NewWindowsShellCOM(log *logger.Logger, config *ConnectionConfig) (*WindowsShellCOM, error) {
	if config == nil {
		config = DefaultConnectionConfig()
	}

	wscom := &WindowsShellCOM{
		log:     log,
		config:  config,
		connected: false,
	}

	// 创建CGO桥接器
	wscom.bridge = NewCGOBridge(log)

	// 初始化CGO桥接器
	if err := wscom.bridge.Initialize(); err != nil {
		return nil, NewMTPError(ERROR_COM_ERROR, "CGO桥接器初始化失败", err)
	}

	wscom.log.Debug("Windows Shell COM访问器创建成功")
	return wscom, nil
}

// ConnectToDevice 连接到指定的MTP设备
func (wscom *WindowsShellCOM) ConnectToDevice(deviceName, vid, pid string) error {
	wscom.log.Debug("使用Windows Shell COM连接到设备: %s", deviceName)

	if wscom.connected {
		wscom.log.Debug("设备已连接，先断开现有连接")
		wscom.Close()
	}

	// 尝试连接设备，支持重试
	var lastErr error
	for attempt := 1; attempt <= wscom.config.MaxRetries; attempt++ {
		wscom.log.Debug("连接尝试 %d/%d", attempt, wscom.config.MaxRetries)

		err := wscom.bridge.ConnectToDevice(deviceName, vid, pid)
		if err == nil {
			break
		}

		lastErr = err
		if attempt < wscom.config.MaxRetries {
			wscom.log.Warn("连接失败，%v后重试: %v", wscom.config.RetryDelay, err)
			time.Sleep(wscom.config.RetryDelay)
		}
	}

	if lastErr != nil {
		wscom.log.Error("所有连接尝试都失败了: %v", lastErr)
		return NewMTPError(ERROR_DEVICE_NOT_FOUND,
			fmt.Sprintf("无法连接到设备: %s", deviceName), lastErr)
	}

	// 创建设备信息
	wscom.device = &DeviceInfo{
		Name:      deviceName,
		VID:       vid,
		PID:       pid,
		DeviceID:  fmt.Sprintf("USB\\VID_%s&PID_%s", vid, pid),
	}

	wscom.connected = true
	wscom.log.Info("成功连接到设备: %s", deviceName)
	return nil
}

// ListFiles 列出指定路径下的文件
func (wscom *WindowsShellCOM) ListFiles(basePath string) ([]*FileInfo, error) {
	if !wscom.connected {
		return nil, NewMTPError(ERROR_DEVICE_NOT_FOUND, "设备未连接", nil)
	}

	wscom.log.Debug("列出文件: %s", basePath)

	// 获取设备路径
	devicePath, err := wscom.bridge.GetDevicePath(wscom.device.Name)
	if err != nil {
		wscom.log.Error("获取设备路径失败: %v", err)
		return nil, NewMTPError(ERROR_ACCESS_DENIED, "无法获取设备路径", err)
	}

	wscom.log.Debug("设备路径: %s", devicePath)

	// 使用CGO桥接器列出文件
	cgoFiles, err := wscom.bridge.ListFiles(devicePath, basePath)
	if err != nil {
		wscom.log.Error("CGO文件列表获取失败: %v", err)
		// 尝试降级到直接文件系统访问
		return wscom.listFilesDirect(devicePath, basePath)
	}

	// 转换为标准FileInfo格式
	files := make([]*FileInfo, 0, len(cgoFiles))
	for _, cgoFile := range cgoFiles {
		file := &FileInfo{
			Path:         cgoFile.Path,
			Name:         cgoFile.Name,
			RelativePath: cgoFile.RelativePath,
			Size:         cgoFile.Size,
			IsOpus:       strings.ToLower(filepath.Ext(cgoFile.Name)) == ".opus",
			ModTime:      time.Now(), // CGO返回的时间需要转换
		}
		files = append(files, file)
	}

	wscom.log.Info("通过Windows Shell COM找到 %d 个文件", len(files))
	return files, nil
}

// listFilesDirect 直接文件系统访问（降级方案）
func (wscom *WindowsShellCOM) listFilesDirect(devicePath, basePath string) ([]*FileInfo, error) {
	wscom.log.Debug("使用直接文件系统访问: %s\\%s", devicePath, basePath)

	fullPath := filepath.Join(devicePath, basePath)

	// 检查路径是否存在
	if _, err := os.Stat(fullPath); os.IsNotExist(err) {
		return nil, NewMTPError(ERROR_DEVICE_NOT_FOUND,
			fmt.Sprintf("路径不存在: %s", fullPath), err)
	}

	var files []*FileInfo
	err := filepath.Walk(fullPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			wscom.log.Warn("访问文件失败: %s, %v", path, err)
			return nil // 跳过错误继续处理
		}

		// 跳过目录
		if info.IsDir() {
			return nil
		}

		// 只处理.opus文件
		if strings.ToLower(filepath.Ext(info.Name())) != ".opus" {
			return nil
		}

		relativePath, err := filepath.Rel(fullPath, path)
		if err != nil {
			relativePath = path
		}

		file := &FileInfo{
			Path:         path,
			RelativePath: relativePath,
			Name:         info.Name(),
			Size:         info.Size(),
			IsOpus:       true,
			ModTime:      info.ModTime(),
		}

		files = append(files, file)
		wscom.log.Debug("发现文件: %s (%.2f MB)", relativePath, float64(info.Size())/1024/1024)
		return nil
	})

	if err != nil {
		wscom.log.Error("文件系统遍历失败: %v", err)
		return nil, NewMTPError(ERROR_ACCESS_DENIED, "文件系统访问失败", err)
	}

	wscom.log.Info("通过直接文件系统访问找到 %d 个文件", len(files))
	return files, nil
}

// GetFileStream 获取文件读取流
func (wscom *WindowsShellCOM) GetFileStream(filePath string) (io.ReadCloser, error) {
	if !wscom.connected {
		return nil, NewMTPError(ERROR_DEVICE_NOT_FOUND, "设备未连接", nil)
	}

	wscom.log.Debug("获取文件流: %s", filePath)

	// 尝试直接打开文件（最简单的方法）
	file, err := os.Open(filePath)
	if err != nil {
		wscom.log.Error("无法打开文件: %v", err)
		return nil, NewMTPError(ERROR_ACCESS_DENIED,
			fmt.Sprintf("无法打开文件: %s", filePath), err)
	}

	wscom.log.Debug("成功打开文件流: %s", filePath)
	return file, nil
}

// Close 关闭连接并释放资源
func (wscom *WindowsShellCOM) Close() error {
	if wscom.bridge != nil {
		wscom.bridge.Close()
	}

	wscom.connected = false
	wscom.device = nil

	wscom.log.Debug("Windows Shell COM访问器已关闭")
	return nil
}

// IsConnected 检查是否已连接到设备
func (wscom *WindowsShellCOM) IsConnected() bool {
	return wscom.connected && wscom.bridge != nil && wscom.bridge.IsConnected()
}

// GetDeviceInfo 获取设备信息
func (wscom *WindowsShellCOM) GetDeviceInfo() *DeviceInfo {
	if !wscom.connected {
		return nil
	}
	return wscom.device
}

// GetLastError 获取最后的错误
func (wscom *WindowsShellCOM) GetLastError() error {
	if wscom.bridge != nil {
		return wscom.bridge.LastError()
	}
	return nil
}