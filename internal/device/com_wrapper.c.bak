#include "com_wrapper.h"
#include <string.h>
#include <time.h>

// 全局COM初始化状态
static int g_com_initialized = 0;

// COM初始化和清理
HRESULT InitializeCOM() {
    if (g_com_initialized) {
        return COM_SUCCESS;
    }

    HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr)) {
        LogError(hr, "CoInitializeEx", "Failed to initialize COM");
        return COM_ERROR_INITIALIZATION_FAILED;
    }

    g_com_initialized = 1;
    return COM_SUCCESS;
}

void UninitializeCOM() {
    if (g_com_initialized) {
        CoUninitialize();
        g_com_initialized = 0;
    }
}

// Windows Shell COM操作
WindowsShellCOM* CreateWindowsShellCOM() {
    WindowsShellCOM* com = (WindowsShellCOM*)malloc(sizeof(WindowsShellCOM));
    if (!com) {
        return NULL;
    }

    memset(com, 0, sizeof(WindowsShellCOM));
    com->last_error = S_OK;

    // 初始化COM（如果尚未初始化）
    HRESULT hr = InitializeCOM();
    if (hr != COM_SUCCESS) {
        com->last_error = E_FAIL;
        return com;
    }

    // 创建Shell实例
    hr = CoCreateInstance(&CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,
                          &IID_IShellDispatch, (void**)&com->shell_dispatch);
    if (FAILED(hr)) {
        LogError(hr, "CoCreateInstance", "Failed to create Shell instance");
        com->last_error = hr;
        return com;
    }

    // 获取桌面文件夹
    hr = com->shell_dispatch->lpVtbl->NameSpace(com->shell_dispatch, 0, (IDispatch**)&com->desktop_folder);
    if (FAILED(hr)) {
        LogError(hr, "Get Desktop Folder", "Failed to get desktop folder");
        // 继续执行，桌面文件夹不是必需的
    }

    // 获取便携式设备文件夹 (Namespace 17)
    IDispatch* portable_dispatch = NULL;
    hr = com->shell_dispatch->lpVtbl->NameSpace(com->shell_dispatch, 17, &portable_dispatch);
    if (SUCCEEDED(hr) && portable_dispatch) {
        hr = portable_dispatch->lpVtbl->QueryInterface(portable_dispatch, &IID_IShellFolder,
                                                       (void**)&com->portable_devices);
        portable_dispatch->lpVtbl->Release(portable_dispatch);

        if (FAILED(hr)) {
            LogError(hr, "QueryInterface", "Failed to get portable devices folder");
            com->portable_devices = NULL;
        }
    } else {
        LogError(hr, "Get Portable Devices", "Failed to get portable devices folder");
        com->portable_devices = NULL;
    }

    com->initialized = TRUE;
    return com;
}

void DestroyWindowsShellCOM(WindowsShellCOM* com) {
    if (!com) {
        return;
    }

    if (com->portable_devices) {
        com->portable_devices->lpVtbl->Release(com->portable_devices);
    }

    if (com->desktop_folder) {
        com->desktop_folder->lpVtbl->Release(com->desktop_folder);
    }

    if (com->shell_dispatch) {
        com->shell_dispatch->lpVtbl->Release(com->shell_dispatch);
    }

    free(com);
}

// 设备操作
HRESULT FindDeviceByName(WindowsShellCOM* com, const wchar_t* device_name, DeviceInfo** device_info) {
    if (!com || !com->initialized || !device_name || !device_info) {
        return COM_ERROR_INVALID_PARAMETER;
    }

    *device_info = NULL;

    IShellFolder* search_folder = com->portable_devices;
    if (!search_folder) {
        search_folder = com->desktop_folder;
    }

    if (!search_folder) {
        return COM_ERROR_DEVICE_NOT_FOUND;
    }

    // 枚举设备
    IEnumIDList* enum_items = NULL;
    HRESULT hr = search_folder->lpVtbl->EnumObjects(search_folder, NULL,
                                                   SHCONTF_FOLDERS | SHCONTF_NONFOLDERS,
                                                   &enum_items);
    if (FAILED(hr)) {
        LogError(hr, "EnumObjects", "Failed to enumerate devices");
        return COM_ERROR_DEVICE_NOT_FOUND;
    }

    PITEMID_CHILD item_id = NULL;
    ULONG fetched = 0;

    while (enum_items->lpVtbl->Next(enum_items, 1, &item_id, &fetched) == S_OK && fetched > 0) {
        STRRET str_name;
        hr = search_folder->lpVtbl->GetDisplayNameOf(search_folder, item_id, SHGDN_NORMAL, &str_name);

        if (SUCCEEDED(hr)) {
            char item_name[MAX_PATH];
            StrRetToBufA(&str_name, item_id, item_name, MAX_PATH);

            // 转换为宽字符进行比较
            wchar_t* wide_name = AnsiToWide(item_name);
            if (!wide_name) {
                CoTaskMemFree(item_id);
                continue;
            }

            // 检查设备名称匹配
            wchar_t* wide_device_name = AnsiToWide(device_name);
            if (wide_device_name && wcsstr(wide_name, wide_device_name) != NULL) {
                // 创建设备信息
                DeviceInfo* info = (DeviceInfo*)malloc(sizeof(DeviceInfo));
                if (info) {
                    memset(info, 0, sizeof(DeviceInfo));
                    info->name = _wcsdup(wide_name);

                    // 获取完整路径
                    char item_path[MAX_PATH];
                    hr = search_folder->lpVtbl->GetDisplayNameOf(search_folder, item_id, SHGDN_FORPARSING, &str_name);
                    if (SUCCEEDED(hr)) {
                        StrRetToBufA(&str_name, item_id, item_path, MAX_PATH);
                        info->path = AnsiToWide(item_path);
                    }

                    // 清理资源
                    if (wide_device_name) {
                        free(wide_device_name);
                    }
                    free(wide_name);

                    *device_info = info;
                    CoTaskMemFree(item_id);
                    enum_items->lpVtbl->Release(enum_items);
                    return COM_SUCCESS;
                }
            }

            // 清理资源
            if (wide_device_name) {
                free(wide_device_name);
            }
            free(wide_name);
        }

        CoTaskMemFree(item_id);
    }

    enum_items->lpVtbl->Release(enum_items);
    return COM_ERROR_DEVICE_NOT_FOUND;
}

HRESULT GetDevicePath(WindowsShellCOM* com, const wchar_t* device_name, wchar_t** path) {
    if (!com || !device_name || !path) {
        return COM_ERROR_INVALID_PARAMETER;
    }

    *path = NULL;

    DeviceInfo* device_info = NULL;
    HRESULT hr = FindDeviceByName(com, device_name, &device_info);
    if (SUCCEEDED(hr) && device_info) {
        if (device_info->path) {
            *path = _wcsdup(device_info->path);
        }
        FreeDeviceInfo(device_info);
        return COM_SUCCESS;
    }

    return COM_ERROR_DEVICE_NOT_FOUND;
}

// 文件操作
HRESULT ListFiles(WindowsShellCOM* com, const wchar_t* device_path, const wchar_t* base_path,
                  FileInfo** files, int* count) {
    if (!com || !device_path || !files || !count) {
        return COM_ERROR_INVALID_PARAMETER;
    }

    *files = NULL;
    *count = 0;

    // 这里需要实现文件列表逻辑
    // 由于复杂性，暂时返回空列表
    // 实际实现需要解析设备路径，遍历文件夹等

    return COM_SUCCESS;
}

// 辅助函数
void FreeDeviceInfo(DeviceInfo* device_info) {
    if (!device_info) {
        return;
    }

    if (device_info->name) {
        free(device_info->name);
    }
    if (device_info->vid) {
        free(device_info->vid);
    }
    if (device_info->pid) {
        free(device_info->pid);
    }
    if (device_info->device_id) {
        free(device_info->device_id);
    }
    if (device_info->path) {
        free(device_info->path);
    }

    free(device_info);
}

void FreeDeviceInfoArray(DeviceInfo* devices, int count) {
    if (!devices) {
        return;
    }

    for (int i = 0; i < count; i++) {
        FreeDeviceInfo(&devices[i]);
    }

    free(devices);
}

void FreeFileInfo(FileInfo* file_info) {
    if (!file_info) {
        return;
    }

    if (file_info->path) {
        free(file_info->path);
    }
    if (file_info->name) {
        free(file_info->name);
    }
    if (file_info->relative_path) {
        free(file_info->relative_path);
    }

    free(file_info);
}

void FreeFileInfoArray(FileInfo* files, int count) {
    if (!files) {
        return;
    }

    for (int i = 0; i < count; i++) {
        FreeFileInfo(&files[i]);
    }

    free(files);
}

wchar_t* AnsiToWide(const char* ansi) {
    if (!ansi) {
        return NULL;
    }

    int len = MultiByteToWideChar(CP_ACP, 0, ansi, -1, NULL, 0);
    if (len <= 0) {
        return NULL;
    }

    wchar_t* wide = (wchar_t*)malloc(len * sizeof(wchar_t));
    if (!wide) {
        return NULL;
    }

    MultiByteToWideChar(CP_ACP, 0, ansi, -1, wide, len);
    return wide;
}

char* WideToAnsi(const wchar_t* wide) {
    if (!wide) {
        return NULL;
    }

    int len = WideCharToMultiByte(CP_ACP, 0, wide, -1, NULL, 0, NULL, NULL);
    if (len <= 0) {
        return NULL;
    }

    char* ansi = (char*)malloc(len);
    if (!ansi) {
        return NULL;
    }

    WideCharToMultiByte(CP_ACP, 0, wide, -1, ansi, len, NULL, NULL);
    return ansi;
}

// 错误处理
const char* GetCOMErrorDescription(HRESULT hr) {
    switch (hr) {
        case S_OK:
            return "Success";
        case E_FAIL:
            return "Unspecified failure";
        case E_INVALIDARG:
            return "Invalid argument";
        case E_OUTOFMEMORY:
            return "Out of memory";
        case E_NOINTERFACE:
            return "No such interface supported";
        case CO_E_NOTINITIALIZED:
            return "COM not initialized";
        case REGDB_E_CLASSNOTREG:
            return "Class not registered";
        default:
            return "Unknown COM error";
    }
}

void LogError(HRESULT hr, const char* function, const char* context) {
    // 这里可以添加日志记录逻辑
    // 暂时使用简单的输出
    printf("COM Error in %s: %s - %s\n", function, GetCOMErrorDescription(hr), context);
}